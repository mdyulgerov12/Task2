Въпрос 1: Дайте пример с C# код, за метод който да сортира  елементите от списъка List<int> list = new List<int>() { 12, 8, 10, 2, 9, 6, 1}; 
посредством алгоритъма за сортиране  чрез пряка селекция. 


Правилният отговор е: 

public static void SelectionSort(List<int> list)
        {
            for (int index = 0; index < list.Count; index++)
            {
                int min = index;
                for (int current = index + 1; current < list.Count; current++)
                {
                    if(list[current] < list[min])
                    {
                        min = current;
                    }
                }

                Swap(list, index, min);
            }
            
        }

private static void Swap(List<int> list, int index, int min)

        {

            int temp = list[index];

            list[index] = list[min];

            list[min] = temp;

        }
        
        
        
  Въпрос 2:  Дайте пример за това къде можете да срещнете поведението на структурата от данни стек във вашето ежедневие. И обяснете защо.
  
  
  
  Правилният отговор е: 

Пример 1 : Работната памет на програмата (стек) - Примитивните типове данни (числа, char, bool) се наричат стойностни типове,
защото пазят непосредствено своята стойност в стека за изпълнение на програмата. 
Стекът е често срещана и използвана структура от данни. Стек се използва и вътрешно от C# 
виртуалната машина за съхранение на променливите в програмата и параметрите при извикване на метод.
Например една променлива, декларирана в метода Main() на програмата се пази в стека докато програмата завърши изпълнението на този метод, т.е. докато не завърши.

Пример 2: Куп с чинии

Пример 3: Куп с книги

Защото: Стекът има поведение последен влязъл пръв излязъл. 
  

Въпрос 3: Даден е аритметичен израз със скоби (може и вложени).
Цел: извличане на всички под-изрази в скоби
Примерен вход: 
1 + (2 - (2 + 3) * 4 / (3 + 1)) * 5


 Правилният отговор е: 
 
Има проблем с кода - при извличането на под-изрази в скоби, крайният резултат може да съдържа неправилни или повтарящи се под-изрази.
За да решим проблема, ще заменим Queue<int> с Stack<int> и ще
използваме методите Push и Pop вместо Enqueue и Dequeue. Това ще гарантира, че под-изразите в скоби се обработват в 
правилния ред и няма повтарящи се или неправилни под-изрази

static void Main(string[] args)

{

  Stack<int> indexes = new Stack<int>();

  string expression = Console.ReadLine();

  for (int i = 0; i < expression.Length; i++)

  {

    if (expression[i] == '(')

    {

      indexes.Push(i);

    }

    else if (expression[i] == ')')

    {

      int startIndex = indexes.Pop();

      int length = i - startIndex + 1;

     string substr = expression.Substring(startIndex, length);

      Console.WriteLine(substr);

    }

  }

}
 
 
 Въпрос 4: Имате следният програмен фрагмент, който трябва да сортира елементите в подаден списък. В кода има грешка и не работи правилно. 
При примерен вход: 36 15 1 7 20 8 24



 
 Правилният отговор е: 
 
 
 var list = Console.ReadLine().Split().Select(int.Parse).ToList();
for (int j = 0; j <= list.Count - 2; j++)
{
    for (int i = 0; i <= list.Count - 2; i++)
    {
        if (list[i] > list[i + 1])
        {
            int temp = list[i];
            list[i] = list[i+1];
            list[i+1] = temp;
        }
    }
}
Console.WriteLine(string.Join(" ", list));
 
 
 
 Въпрос 5: Дадени са следните картинки:

Това е визуализация на един от алгоритмите за сортиране. За този алгоритъм важи следното правило: 
Взема първият елемент в масива (29) и го сравнява със всеки следващ (10, 14, 37...) докато не намери
най-малкия елемент (2). Разменя намереният най-малък елемент (2) с първоначално избрания (29). Тези стъпки се повтарят докато елементите в масива не се сортират.
Посочете кой от видовете алгоритми е използван:
 
  
Правилният отговор е: Сортиране на елементите чрез пряка селекция.



Въпрос 6: На картинката е показана илюстрация на един от видовете алгоритми за сортиране. Посочете кой е той:

Правилният отговор е: Сортиране чрез сливане (Merge sort)



Въпрос 7:Имате даден програмен фрамент от код написан на C#.


Правилният отговор е:

 static void LongestSequenceEqualNumbers()
        {
            //List<int> nums = Console.ReadLine().Split().ToList(); 
            List<int> nums = Console.ReadLine().Split().Select(int.Parse).ToList();

            //int bestStart = 0 
            int bestStart = 0;
            int bestLength = 1;
            int currentLength = 1;
            int index = 0;
            int first = nums[index];

            for (int i = 1; i < nums.Count; i++)
            {
                if (first == nums[i])
                {
                    currentLength++;
                    if (currentLength > bestLength)
                    {
                        bestLength = currentLength;
                        //bestStart = index; 
                        bestStart = index;
                    }
                }
                else
                {
                    first = nums[i];
                    index = i;
                    //currentLength = 1; 
                    currentLength = 1;
                }
            }

            for (int i = bestStart; i < bestStart + bestLength; i++)
            {
                Console.Write($"{nums[i]} ");
            }
        }

 static void LongestSequenceEqualNumbers()
        {
            //List<int> nums = Console.ReadLine().Split().ToList(); 
            List<int> nums = Console.ReadLine().Split().Select(int.Parse).ToList();

            //int bestStart = 0 
            int bestStart = 0;
            int bestLength = 1;
            int currentLength = 1;
            int index = 0;
            int first = nums[index];

            for (int i = 1; i < nums.Count; i++)
            {
                if (first == nums[i])
                {
                    currentLength++;
                    if (currentLength > bestLength)
                    {
                        bestLength = currentLength;
                        //bestStart = index; 
                        bestStart = index;
                    }
                }
                else
                {
                    first = nums[i];
                    index = i;
                    //currentLength = 1; 
                    currentLength = 1;
                }
            }

            for (int i = bestStart; i < bestStart + bestLength; i++)
            {
                Console.Write($"{nums[i]} ");
            }
        }


Въпрос 8:  Запазете историята на браузъра. Ще получите възможни команди:
URL – отваря дадената страница
back – връща към предната страница
exit – спира програмата






Правилният отговор е:

Грешката в кода се намира в реда:

Console.WriteLine(pages.Remove);

pages.Remove е метод, който премахва последния елемент в списъка и връща неговата стойност. 
Това не трябва да се изписва на конзолата. За да се изписа стойността на предишната страница, трябва да се използва предишно зададената променлива previous.



Поправеният код вижда се по-долу:

static void Main(string[] args)

 { 

List<string> pages = new List<string>(); 

string command = Console.ReadLine(); 

string previous = null; 

while (!"exit".Equals(command))

 {

 if (command.Equals("back"))

 {

 if (pages.Count != 0) 

{ 

previous = pages[pages.Count - 1]; 

pages.RemoveAt(pages.Count - 1); 

Console.WriteLine(previous); 

} 

else { 

Console.WriteLine("No previous pages"); 

} 

} 

else 

{ 

if (previous != null) 

{ 

pages.Add(previous); 

} 

previous = command; 

Console.WriteLine(command); 

} 

command = Console.ReadLine(); 

} 

}



Въпрос 9: Изчислете какъв ще бъде отговорът на следния пример:

През 2013 ООН има 193 страни членки. Ако имената на тези страни са сортирани по азбучен ред в масив, колко имена трябва да провери 
двоичното търсене, за да намери конкретно име в масива в най-лошия случай?



Правилният отговор е:  [Не повече от 8.]


Въпрос 10: Имате зададени твърдения за два алгоритъма за търсене - двоично търсене и интерполационно търсене.
По зададените твърдения и характеристики трябва да сравните двата алгоритъма и да зададете коя от тях към кой от алгоритмите се отнася:


Правилният отговор е:


Стойностите в масива трябва да са сортирани и равномерно разпределени. [Интерполационно търсене]

Работи във времева сложност O(log n). [Двоично търсене]

Ако ключът е по-малък от средния елемент, тогава ключът може да лежи само в левия подмасив. [Отнася се и за двата алгоритъма]

Работи във времева сложност O(log(log n)). [Интерполационно търсене] 

Ако ключът е по-голям от средния елемент, тогава ключът може да лежи само в десния подмасив. [Отнася се и за двата алгоритъма]

Може да се оцени позицията на стойността на ключа в масива,като се вземат предвид най-малкият и най-големият
елемент в масива и дължината на масива. [Интерполационно търсене]

Оценява средната позиция за масива и сравнява този елемент с желания ключ. [Интерполационно търсене]

Ако ключът съвпада със средния елемент, върнете средното местоположение. [Отнася се и за двата алгоритъма]


Въпрос 11: Имате следния програмен фрагмент:
private static long sum 



Правилният отговор е: Ако имаме два вложени цикъла съответно от 1 до N и от 1 до M, сложността им е квадратична – O(N*М)




Въпрос 12:  Посочете вярното за следното твърдение:


Правилният отговор е:  [Enqueue] – добавя елемент в края на опашката



Въпрос 13:  Посочете за алгоритми с каква сложност се отнася следното твърдение:


Правилният отговор е:

Алгоритми с [константна, логаритмична и линейна] сложност са толкова бързи, че не 
можем да усетим забавяне, дори при относително голям размер на входните данни.

 

Въпрос 14:  Имате следния програмен фрагмент:

public static  int  FindInversions


Правилният отговор е:  Ако имаме два вложени цикъла от 1 до N, сложността им е квадратична – O(N2).


Въпрос 15: Ако имате следната последователност от числа: "15, 85, 34, 12, 0, -9, 14, 63, 7, 32" и трябва да 
     напишете алгоритъм, който да намери елемент от този списък, например числото 34. 



Правилният отговор е:

Линейното търсене е прост подход за намиране на елемент в списък.

Започваме от най-левия елемент на масива и едно по едно сравняваме търсеното число (х) с всеки елемент на масива.

Ако x съвпада с елемент от масива, връщаме индекса, в случая числото 34 е на индекс 2 и алгоритъма трябва да върне числото 2 като резултат.

Ако x не съвпада с нито един от елементите, връщаме -1.




Въпрос 16: ефинирайте понятието сложност на алгоритъм, като попълните липсващите думи в текста.


Правилният отговор е:

 Сложност на алгоритъм е [груба оценка на броя стъпки], които алгоритъмът ще направи в зависимост от [размера на входните данни]. 
 Това е груба оценка, която се интересува от [порядъка на броя стъпки], а не от [точния им брой].


Въпрос 17: Дайте пример за това къде можете да срещнете поведението на структурата от данни опашка във вашето ежедневие. И обяснете защо.


Правилният отговор е:

Пример : Например опашка от хора, чакащи на каса за билети. Опашката има начало и край. 
Новодошлите хора застават последни на опашката и изчакват докато постепенно се придвижат към началото. 
Когато стигнат до самото начало на опашката си купуват билет и напускат опашката. 


Защото: Структурата от данни опашка изпълнява условието „първият влязъл първи излиза“ (FIFO: First-In-First-Out). 
Това означава, че след като е добавен един елемент в края на опашката, 
той ще може да бъде извлечен (премахнат) единствено след като бъдат премахнати всички елементи преди него в реда, в който са добавени.

 
 Въпрос 18: Да кажем, че играем на игра, в която трябва да познаете числото. Имате списък с числа от  1 до 20 включително подредени във възходящ ред. 
   Решете задачата, като намерите кое е търсеното число и използвания алгоритъм за търсене на числото. 

 
 Правилният отговор е:
 
 Позна ли кое е моето число? [Търсеното число е 3]

Кой алгоритъм за търсене използва? [Двоично търсене]



Въпрос 19: Имате даден следния програмен фрагмент:


public T Pop(int index)
        {
            if (this.Count == 0)
            {
                throw new InvalidOperationException("Empty stack");
            }
            T element = this.items[index]; 
            T[] temp = new T[this.items.Length];
            for (int i = 0; i < this.Count; i++)
            {
                temp[i] = this.items[i];
            } 
            this.items = temp;
            return element;
        }
        
        
        
   Правилният отговор е:
   
   
   Грешката в кода е, че методът Pop(int index) получава цяло число, което вътре в метода се използва за намиране на елемента в масива и премахването на този елемент.
   По дефиниция линейната структура стек не работи така. 
   Правилото за работа със стек е "първи влиза - първи излиза". Нямаме право да достъпваме елементите по индекс, освен само и единствено за четене. 
   Когато правим имплементацията за премахване на елемент от стек винаги премахваме последния елемент -
   в случая трябва да използваме броя на елементите (Count) на мястото на параметъра Index, за да премахнем последния елемент от масива в класа. 
   И самия метод Pop() не трябва да приема параметър.
   

public T Pop()
        {
            if (this.Count == 0)
            {
                throw new InvalidOperationException("Empty stack");
            }
            this.Count--;//2т
            T element = this.items[this.Count];

            T[] temp = new T[this.items.Length];
            for (int i = 0; i < this.Count; i++)
            {
                temp[i] = this.items[i];
            }

            this.items = temp;
            return element;
        }




Въпрос 20: Имате дадени твърдения. Вие трябва да можете да различавате и сравнявате видовете структури от данни. 
Срещу всяко едно от тези твърдения трябва да зададете правилната структура от данни за която то се отнася.

 
 
 Правилният отговор е:
 
 
За добавяне на елемент в структурата от данни използва операцията Push(T). [Стек]

Можем да обходим елементите в структура от данни тип опашка с  помощта на for-цикъл. [Твърдението не е вярно]

За премахване на елемент от структурата от данни използва операцията Dequeue(). [Опашка]

За премахване на елемент от структурата от данни използва операцията Pop(). [Стек]

Структура от данни, която има поведението първи влязъл първи излязъл. [Опашка]

Можем да достъп елемент от структурата от данни стек, като използваме операцията Peek(index) неговия индекс. [Твърдението не е вярно]

Структура от данни, която има поведението последен влязъл първи излязъл. [Стек]

За добавяне на елемент в структурата от данни използва операцията Enqueue(T). [Опашка]




Въпрос 21:Имате даден следният програмен фрагмент. Свържете правилно липсващите части от кода.  



Правилният отговор е:


int low = 0;
            int high = sortedArray.Length - 1;
            while (sortedArray[[low]] <= key && sortedArray[[high]] >= key)
            {
                int mid = low + ((key - sortedArray[low]) * (high - low))
                  / (sortedArray[high] - sortedArray[low]);
                if ([sortedArray[mid] < key])
                    low = mid + 1;
                else if ([sortedArray[mid] > key])
                    high = mid - 1;
                else
                    return mid;
            }
            if ([sortedArray[low] == key]) return low;
            else return -1;



Въпрос 22: Показани са означенията на типовете сложност на алгоритъм, посочете съответстващата му сложност, като изберете от падащия списък срещу всяко от означенията:


Правилният отговор е:


O(n3)        [кубична]

O(log(N))  [логаритмична]

O(N)         [линейна]

O(2n)        [експоненциална]

О(n2)        [квадратична]

O(1)          [константна]

O(N!)        [експоненциална]





Въпрос 23:  Имате следния пример:

Трябва да намерите елемент в масив по даден ключ. Посочете сложността на алгоритъма в най-лошия, среден и най-добър случай:



Правилният отговор е:


Най-лош случай: [O(N)]

Среден случай: [O(N)]

Най-добър случай: [O(1)]


Въпрос 24:  Дайте пример с C# код, за метод който да сортира  елементите от списъка List<int> list = new List<int>() { 12, 8, 10, 2, 9, 6, 1}; 
посредством алгоритъма за сортиране  чрез пряка селекция. 




Правилният отговор е:


public static void SelectionSort(List<int> list)
        {
            for (int index = 0; index < list.Count; index++)
            {
                int min = index;
                for (int current = index + 1; current < list.Count; current++)
                {
                    if(list[current] < list[min])
                    {
                        min = current;
                    }
                }

                Swap(list, index, min);
            }
            
        }

private static void Swap(List<int> list, int index, int min)

        {

            int temp = list[index];

            list[index] = list[min];

            list[min] = temp;

        }
        
        
        
        
    Въпрос 25:  Обяснете какво прави методът Dequeue()?
    
    
    Правилният отговор е: премахва и връща елемента от началото на опашката
    
    
    
    
    
