Въпрос 1:  Демонстрирайте синхронизацията на нишки, чрез правилно прилагане на lock операторите,
           така че програмата да не изпада в безкраен цикъл и да се избягва проблема „мъртва хватка“ (deadlock).



Правилният отговор е: 


class Program

{

    static object lockObject = new object();



    static void Main(string[] args)

    {

        Thread thread1 = new Thread(DoWork);

        Thread thread2 = new Thread(DoWork);



        thread1.Start();

        thread2.Start();



        thread1.Join();

        thread2.Join();



        Console.WriteLine("Finished.");

        Console.ReadKey();

    }



    static void DoWork()

    {

        lock (lockObject)

        {

            Console.WriteLine("Thread {0} has entered the lock.", Thread.CurrentThread.ManagedThreadId);

            Thread.Sleep(1000);

            Console.WriteLine("Thread {0} is leaving the lock.", Thread.CurrentThread.ManagedThreadId);

        }

    }

}



Въпрос 2:  Демонстрирайте създаването и стартирането на нишка, която изпълнява метода по-долу. 
        Включете целия необходим код в отговора, в това число class Program и Main метод.


static void PrintTriangle(int n) {

    for(int i = 1; i <= n; i++)
    {
        for(int j = 1; j <= i; j++)
        {
           Console.Write($"{j} ");
        }
        Console.WriteLine();
    }

}



Правилният отговор е: 


 class Program

{

    static void Main(string[] args)

    {

        // Създаване на нова нишка

        Thread thread = new Thread(() =>

        {

            PrintTriangle(5);

        });



        // Стартиране на нишката

        thread.Start();



        Console.WriteLine("Main thread has finished.");

        Console.ReadKey();

    }


    static void PrintTriangle(int n)

    {

        for (int i = 1; i <= n; i++)

        {

            for (int j = 1; j <= i; j++)

            {

                Console.Write($"{j} ");

            }

            Console.WriteLine();

        }

    }

}




Въпрос 3:  Посочете вярното твърдение за нишка


Правилният отговор е: Нишките могат да се изпълняват конкурентно




Въпрос 4:  По време на теоретичния изпит се предоставя непълен/неработещ/некоректен програмен фрагмент. Предоставеният фрагмент да се приведе в работещ вид.



Правилният отговор е:


using System;

using System.Collections.Generic;

using System.Linq;

using System.Threading;


namespace ExampleThread1

{

class Program

[{]

[static] void FindMin(int[] arr)

{

[int min = arr[0];]

[for (int i = 0; i < arr.Length; i++)]

{

if ([arr[i] < min])

{

min = [arr[i]];

}

}

Console.WriteLine($"Minimum: {min}");

}

static void FindMax([int[] arr])

{

int max = arr[0];

for (int i = 0; i < arr.Length; i++)

{

if (arr[i] > max)

{

[max = arr[i];]

}

}

Console.WriteLine($"Maximum: {max}");

}

static void Main(string[] args)

{

int n = int.Parse(Console.ReadLine());

int[] arr = new int[n];

Random r = new Random();

for (int i = 0; i < n; i++)

{

arr[i] = r.Next(-100, 100);

}


[Thread t1 = new Thread(() => FindMin(arr));]

Thread t2 = new Thread(() => FindMax(arr));

t1.Start();

t2.Start();

[}]

}

}




Въпрос 5:  Открийте какъв проблем при употреба на нишки се наблюдава в примерния програмен фрагмент и предложете решение.



Правилният отговор е: 


В предоставения програмен фрагмент липсва синхронизация на достъпа до масива "arr" от двата метода "FindMin" и "FindMax", които се изпълняват в различни нишки. 
Това може да доведе до некоректни резултати, тъй като двата метода могат да достъпват едновременно елементи на масива и да 
променят стойността им преди другия метод да ги прочете.
Решението на този проблем е да се използва монитор за блокиране на достъпа до масива от двата метода.
Мониторът гарантира, че само една нишка може да достъпва масива в даден момент от време, като блокира достъпа до него за другите нишки,
докато текущата нишка не приключи работата си с него.
Ето как бихме модифицирали методите "FindMin" и "FindMax" за да се използва монитор за синхронизация на достъпа до масива:



static object lockObject = new object();



static void FindMin(int[] arr)

{

    int min = arr[0];

    lock (lockObject)

    {

        for (int i = 1; i < arr.Length; i++)

        {

            if (arr[i] < min)

            {

                min = arr[i];

            }

        }

    }

    Console.WriteLine($"Minimum: {min}");

}



static void FindMax(int[] arr)

{

    int max = arr[0];

    lock (lockObject)

    {

        for (int i = 0; i < arr.Length; i++)

        {

            if (arr[i] > max)

            {

                max = arr[i];

            }

        }

    }

    Console.WriteLine($"Maximum: {max}");

}

В този модифициран код използваме lock оператора за блокиране на достъпа до масива "arr" в двете нишки. 
Заключваме достъпа до масива във всеки метод, като използваме общ обект "lockObject" за монитор.
Това гарантира, че само една нишка може да достъпва масива в даден момент от време, 
като блокира достъпа до него за другите нишки, докато текущата нишка не приключи работата си с него.



Въпрос 6: Между процесите и нишките съществува връзка. Кое от тези твърдения описва вярно тази връзка?


Правилният отговор е: множество нишки на различни програми може да бъдат изпълнявани от даден процес


Въпрос 7:  Демонстрирайте създаването и стартирането на нишка, която изпълнява метода по-долу. 
          Включете целия необходим код в отговора, в това число class Program и Main метод.
          
          static void SayHello(string name) {

    Console.WriteLine($"Hello, {name}!");

}
          
  Правилният отговор е:
  
  
  using System;

using System.Threading;



class Program

{

    static void Main(string[] args)

    {

        Thread t = new Thread(() => SayHello("John"));

        t.Start();

        Console.WriteLine("Main thread finished");

    }



    static void SayHello(string name)

    {

        Console.WriteLine($"Hello, {name}!");

    }

}


Въпрос 8:  Дефинирайте понятието конкурентност.




Правилният отговор е: 

Конкурентността е свойство на софтуерни системи, което позволява на две или повече задачи да се изпълняват едновременно и независимо една от друга.
Това се постига чрез използване на многонишково програмиране, където всяка нишка изпълнява своя код паралелно с другите нишки.

В конкурентните системи, задачите се изпълняват възможно най-ефективно и бързо, като се използват всички налични ресурси, включително процесорното 
време и паметта. Конкурентността може да подобри ефективността и производителността на софтуерните системи, тъй като повече задачи могат да бъдат 
изпълнени за по-кратко време.

Въпреки това, конкурентността може да доведе до някои проблеми, като мъртва хватка (deadlock) и състезание за ресурси (race condition), когато
няколко нишки се опитват да достъпят един и същи ресурс едновременно. Затова е важно да се прилагат правилни практики за програмиране на многонишкови 
системи и да се използват инструменти за управление на конкурентността, като синхронизационни механизми и протоколи за комуникация между нишки.
  
  
Въпрос 9:  Кое от следните НЕ е метод на Thread обекта.



Правилният отговор е: Stop




Въпрос 10: Дефиницията „Абстракция на програма в режим на изпълнение” е на понятието:



Правилният отговор е: процес




Въпрос 11:  Дайте пример за ситуация, в която възниква проблем „гладуване“ (starvation)?


Правилният отговор е:


Проблемът "гладуване" (starvation) се появява, когато някои задачи в системата не могат да получат достъп до ресурсите, от които се нуждаят за да бъдат изпълнени. 
Този проблем може да се появи, когато някои задачи използват ресурсите за продължителен период от време или когато други задачи се опитват да ги достъпят постоянно.

Един пример за ситуация, в която възниква проблемът "гладуване", е при използване на синхронизационни механизми в многонишкови приложения. 
Ако някои нишки в приложението са постоянно блокирани от други нишки, които използват същите ресурси, това може да доведе до гладуване на тези нишки.

Например, ако имаме система с две нишки - една за запис на данни и друга за извличане на данни от база данни, може да се появи проблем на гладуване, 
ако нишката за запис на данни постоянно използва базата данни, като не освобождава ресурса за достъп от други нишки. Това може да доведе до блокиране на 
нишката за извличане на данни, която не може да получи достъп до базата данни за да извлече необходимата информация.



Въпрос 12:  Кое от следните НЕ е състояние на нишка?

Правилният отговор е: „в изчакване” (Awaiting)



Въпрос 13:  Дайте пример за поне два вида конкурентност.


Правилният отговор е:


Конкурентността може да се постигне по много начини. Вот няколко примера:

Конкурентност на нишки: Многонишковите приложения са пример за конкурентност на нишки. В тези приложения, няколко нишки могат да изпълняват 
едновременно различни задачи, катосе състезават за ресурси и използват синхронизационни механизми за да се избегне проблемът
"мъртва хватка" (deadlock) или "гладуване" (starvation).

Конкурентност на процеси: Многопроцесорните системи са пример за конкурентност на процеси. 
В тези системи, няколко процеса могат да работят едновременно, като се състезават за общи ресурси като паметта, входно-изходните устройства и др.

Конкурентност на заявки: Когато множество потребители или приложения едновременно заявят достъп до една база данни или мрежово приложение, 
това може да доведе до конкурентност на заявките. В тези случаи, се използват синхронизационни механизми като транзакции и оптимистично заключване, за да се 
избегне проблемът"мъртва хватка" и да се гарантира целостта на данните.

Конкурентност на задачи: В модерните операционни системи като Windows и Linux, конкурентността на задачите е използвана за ускоряване на работата на 
компютърната система. Например, операционната система може да изпълнява няколко задачи едновременно, като се използва време-делене (time-sharing) за да се сменят
между тях и да се осигури бързо реагиране на потребителите.




Въпрос 14:  Кой е проблемът, който отговаря на посоченото описание?
Това е самоизключващо се блокиране.
Такова състояние може да възникне, ако нишка А засече, че нишка Б се опитва да заеме ресурс и се опита да го освободи. 
От своя страна при получаване на ресурса нишка Б също се опитва да го освободи отново за нишка А. Това може да продължи до безкрайност.


Правилният отговор е: Жива хватка (livelock)



Въпрос 15:  Дефинирайте понятието блокираща операция.



Правилният отговор е:


Блокираща операция е операция, която блокира или задържа изпълнението на програмата до като се изпълнят определени условия. 
Тези условия могат да включват чакане за изпълнение на друга операция, заетост на ресурс или друга нишка, или някакво друго събитие,
което трябва да се случи преди продължаване на изпълнението на програмата.

Такива операции могат да доведат до забавяне на работата на програмата и да заемат ресурси, което може да доведе до проблеми с конкурентността на програмата. 
Затова е важно да се избягват блокиращи операции, когато е възможно и да се използват асинхронни механизми за обработка на събития и задачи.





Въпрос 16:  Изберете липсващата фраза, така че да дефинирате правилно понятието:
______________________________ наричаме такава операция, която възпрепятства продължението на изпълнение на програмата до приключване на съответната операция.



Правилният отговор е: блокираща




Въпрос 17:  Открийте какъв проблем при употреба на нишки се наблюдава в примерния програмен фрагмент и предложете решение.


Правилният отговор е:


Проблемът в примерната програма е, че нишката t1 е създадена, но никога не е стартирана. 
Това означава, че методът PrintBunny никога няма да бъде изпълнен.

За да коригирате това, нишката t1 трябва да бъде стартирана чрез извикване на метода Start. Ето актуализирана версия на кода:

class Program 

 {

    static void PrintBunny()

    {

        Console.WriteLine(@"|)___(|");

        Console.WriteLine(@"(o . o)");

        Console.WriteLine(@"(_).(_)");

    }



    static void Main()

    {

        Thread t1 = new Thread(PrintBunny);

        t1.Start();

    }

 }





